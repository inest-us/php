<? 

require_once ("class.exceptions.php");

/**
 * Class: LogUtils
 *
 * Responsibilities:
 *   Varied and many, but database abstraction functions happen to
 *   live here.
 *
 * Collaborations:
 *   Used by nearly every MultiLog class.
 *   Has some global dependencies.
 *
 * Static because it requires no state, and is defined as a class to 
 * avoid namespace pollution/collsions.
 */
abstract class LogUtils
{
    /**
     * Returns default if the source is not defined
     */
    public static function getDef (&$source, $default)
    {
        if ( !empty ($source)) return $source;
        return $default;
    }

    /**
     * Works just like implode, except everything gets quoted.
     */
    public static function implodeQuoted (&$values, $delimiter)
    {
        $sql = "";
        $flagIsFirst = true;
        foreach ($values as $value) {
            if ($flagIsFirst) {
                $flagIsFirst = false;
            } else {
                $sql .= $delimiter;
            }
            
            if (gettype ($value) == "string") {
                $sql .= "'".$value."'";
            } else {
                $sql .= $value;
            }
        }
        return $sql;
    }

    /**
     * in ISO format
     */
    public static function formattedDate () 
    {
        return substr(date("c"), 0, 10);
    }
    
    /**
     * in ISO format
     */
    public static function formattedTime () 
    {
        return substr(date("c"), 11, 8);
    }
    
    /**
     * Flattens a multi-dimensional array to the Nth element.
     */
    public static function arrayNth ($a, $n) {
        $out = array();
        foreach ($a as $item) {
            $out[$item[$n]]=$item[$n];
        }
        return $out;
    }
    
    /**
     * Dump the results of the query to a multidimensional array.
     */
    public static function queryToMultidimArray ($db, $sql) 
    {
        $out = array();
    
        $query = LogUtils::executeQuery ($db, $sql);
    
        if ( !$query ) {
            throw new MultiLogDatabaseQueryException ($sql); 
        }
    
        while ($row = LogUtils::getQueryArray($query)) {
            array_push ($out, $row);
        }    
    
        return $out;
    }

    /**
     * Convenience function to return all unique sites the logs have used
     */
    public static function gatherSites ($db) 
    {
        return LogUtils::queryToMultidimArray(
            $db, "select distinct site_id from user_log order by site_id");
    }
    
    /**
     * Convenience function to return all unique sections/demo_ids
     */
    public static function gatherSections ($db) 
    {
        return LogUtils::queryToMultidimArray (
            $db, "select distinct demo_id from user_log order by demo_id");
    }

    /**
     * Start of the database abstractions
     */ 
    public static function openDatabase () 
    {
        $db = sqlite_popen($GLOBALS['dbpath'].$GLOBALS['dbname'], 0666, $err);
        if ( !$db ) {
            throw new MultiLogOpenDatabaseException ();
        }
        return $db;
    }

    /**
     * Since THIS database happens to be persistant (via popen), closing 
     * the connection would actually close ALL connections because the 
     * connection is shared across all opens.
     *
     * Implementation detail.
     */
    public static function closeDatabase ($db) 
    {
        // this is what it might look like:
        //    if ( $db ) {
        //        sqlite_close ($db);
        //    }
    }

    /**
     * This should drive any self-respecting DBA into conniptions.  Prepared
     * statements are far more efficient, but in our case sqlite dosen't really
     * care.
     */
    public static function generateSqlInsert ($tableName, &$metas, &$values)
    {
        return "insert into ".$tableName.
            "        ( ".implode                 ($metas,  ", ")." ) ".
            " values ( ".LogUtils::implodeQuoted ($values, ", ")." ) ";
    }

    /**
     * Return the last error generated by the database.  
     */
    public static function databaseError ($db) 
    {
        $err = "";
    
        if ( $db ) {
            $err = "error #".sqlite_last_error($db).
                " : ".sqlite_error_string (sqlite_last_error($db));
        }
        return $err;
    }

    /**
     * In the name of db abstraction.
     */
    public static function executeQuery ($db, $sql)
    {
		return sqlite_query($sql, $db);
    }
    
    /**
     * In the name of db abstraction.
     */
    public static function getLastInsertedRowId ($db)
    {
        return sqlite_last_insert_rowid($db);
    }

    /**
     * In the name of db abstraction.
     */
    public static function getQueryArray ($query)
    {
        return sqlite_fetch_array ($query);
    }
}

?>
